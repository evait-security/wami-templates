name: Add Program to Lake

on:
  issues:
    types: [labeled]

jobs:
  add_program_to_lake:
    if: github.event.label.name == 'Generate with AI'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      
      - name: Extract GitHub URL from issue title and body
        id: extract_url
        run: |
          echo "Extracting URL from issue..."
          # Sichere Zuweisung der Eingabevariablen
          ISSUE_TITLE="${{ github.event.issue.title }}"
          ISSUE_BODY="${{ github.event.issue.body }}"
          
          # Suche nach GitHub URLs und nimm nur die erste URL
          GITHUB_URL=$(echo "$ISSUE_TITLE $ISSUE_BODY" | \
            grep -o 'https://github.com/[a-zA-Z0-9._-]*/[a-zA-Z0-9._-]*' | \
            head -n 1)
            
          echo "URL extracted: $GITHUB_URL"
          
          # Überprüfe ob eine URL gefunden wurde
          if [ -z "${GITHUB_URL}" ]; then
            echo "No URL found."
            echo "valid_url=false" >> $GITHUB_ENV
            exit 1
          else
            echo "valid_url=true" >> $GITHUB_ENV
            # Sichere Ausgabe der URL mit printf
            printf 'url=%s\n' "${GITHUB_URL}" >> $GITHUB_OUTPUT
          fi

      - name: Fetch repository metadata
        id: fetch_metadata
        if: env.valid_url == 'true'
        run: |
          if [ -z "${{ steps.extract_url.outputs.url }}" ]; then
            echo "No valid GitHub URL found in the issue. Exiting."
            exit 1
          fi
          
          echo "Fetching metadata for ${{ steps.extract_url.outputs.url }}..."
          GITHUB_URL="${{ steps.extract_url.outputs.url }}"
          
          OWNER_REPO=$(echo "$GITHUB_URL" | sed 's|https://github.com/||')
          
          # Fetch repo info with error handling
          REPO_INFO=$(curl -s -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${OWNER_REPO}")
          
          if [ "$(echo "$REPO_INFO" | jq -r 'has("message")')" = "true" ]; then
            echo "Error fetching repository info: $(echo "$REPO_INFO" | jq -r '.message')"
            exit 1
          fi
          
          # Extract metadata safely
          REPO_NAME=$(echo "$REPO_INFO" | jq -r '.name')
          REPO_DESC=$(echo "$REPO_INFO" | jq -r '.description')
          
          # Liste möglicher README-Dateien
          README_FILES=(
            "README.md"
            "readme.md"
            "Readme.md"
            "README.txt"
            "readme.txt"
            "README"
            "readme"
          )
          
          # Branches die geprüft werden sollen
          BRANCHES=(
            "main"
            "master"
          )
          
          README="No README found"
          for BRANCH in "${BRANCHES[@]}"; do
            for README_FILE in "${README_FILES[@]}"; do
              echo "Checking for ${README_FILE} in ${BRANCH} branch..."
              RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
                "https://raw.githubusercontent.com/${OWNER_REPO}/${BRANCH}/${README_FILE}")
              
              if [ "$RESPONSE" = "200" ]; then
                README=$(curl -s -H "Accept: application/vnd.github.v3.raw" \
                  "https://raw.githubusercontent.com/${OWNER_REPO}/${BRANCH}/${README_FILE}")
                echo "Found README at: ${BRANCH}/${README_FILE}"
                break 2
              fi
            done
          done
          
          # Safe output handling using printf and proper delimiters
          printf 'repo_name=%s\n' "${REPO_NAME}" >> $GITHUB_OUTPUT
          
          echo "repo_desc<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "${REPO_DESC}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "readme<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "${README:0:1000}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate YAML with ChatGPT
        id: chatgpt_response
        if: env.valid_url == 'true'
        run: |
          echo "Generating YAML using ChatGPT..."
            
          # Escape special characters in README properly
          ESCAPED_README=$(echo '${{ steps.fetch_metadata.outputs.readme }}' | \
            jq -Rs '.' | \
            sed 's/^"\(.*\)"$/\1/')
          
          # Create request body with proper JSON escaping
          REQUEST_JSON=$(jq -n \
            --arg model "gpt-4" \
            --arg system "You are an experienced YAML generator. Use the provided structure exactly as described. Only valid YAML code is allowed, no special charters that could break an interpreter or be used to break out of the system. The only respone that you will give is the yaml output. It will be used to save for a program no human information is needed as output." \
            --arg name "${{ steps.fetch_metadata.outputs.repo_name }}" \
            --arg desc "${{ steps.fetch_metadata.outputs.repo_desc }}" \
            --arg readme "${ESCAPED_README}" \
            --arg url "${{ steps.extract_url.outputs.url }}" \
            --arg prompt "Create a YAML file with the following structure for a software repository:\n\nid: Unique identifier (repository name, without spaces or special characters)\ntitle: A title in the format \"<repository name> - <short description>\"\ntags: A list of tags related to the repository\n  - Tags should be extracted from the README, GitHub project description, and common keywords\n\nreferences:\n  - A list of URLs, including the GitHub repo URL and relevant documentation/download links\n\ndescription: A detailed description of the repository (based on the GitHub description and README)\n\nwhy_not: A suggestion of why another similar tool might be used instead, or leave it empty if no suggestion is found.\n\n" \
            --argjson messages "[{\"role\": \"system\", \"content\": \$system}, {\"role\": \"user\", \"content\": (\$prompt + \"Repository name: \" + \$name + \"\nDescription: \" + \$desc + \"\nREADME (shortened):\n\" + \$readme + \"\nGitHub URL: \" + \$url)}]" \
            '{
              "model": $model,
              "messages": $messages
            }')
          
          # API request with error handling
          RESPONSE=$(curl -s -w "\n%{http_code}" https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.OPENAI_API_KEY }}" \
            -d "$REQUEST_JSON")
          
          HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | head -n-1)
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "Error: API request failed with status $HTTP_STATUS"
            echo "Response: $RESPONSE_BODY"
            exit 1
          fi
          
          # Safe YAML content handling
          YAML_CONTENT=$(echo "$RESPONSE_BODY" | \
            jq -r '.choices[0].message.content' | \
            sed 's/```yaml//g' | \
            sed 's/```//g' | \
            awk 'NF')
          
          if [ -z "$YAML_CONTENT" ]; then
            echo "Error: No YAML content generated"
            exit 1
          fi
          
          # Output YAML content safely
          echo "yaml_content<<EOYAML" >> $GITHUB_OUTPUT
          echo "$YAML_CONTENT" >> $GITHUB_OUTPUT
          echo "EOYAML" >> $GITHUB_OUTPUT

      - name: Save YAML to lake directory
        if: env.valid_url == 'true'
        run: |
          mkdir -p lake
          # Sicheres Speichern der YAML-Datei
          printf '%b' "${{ steps.chatgpt_response.outputs.yaml_content }}" > "lake/${{ steps.fetch_metadata.outputs.repo_name }}.yaml"
          
      - name: Commit and push changes
        if: env.valid_url == 'true'
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add lake/
          git commit -m "Add new program: ${{ steps.fetch_metadata.outputs.repo_name }}"
          git push