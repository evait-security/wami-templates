name: Add Program to Lake

on:
  issues:
    types: [labeled]

jobs:
  add_program_to_lake:
    if: github.event.label.name == 'Generate with AI'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      
      - name: Extract GitHub URL from issue title and body
        id: extract_url
        run: |
          echo "Extracting URL from issue..."
          # Sichere Zuweisung der Eingabevariablen
          ISSUE_TITLE="${{ github.event.issue.title }}"
          ISSUE_BODY="${{ github.event.issue.body }}"
          
          # Suche nach GitHub URLs und nimm nur die erste URL
          GITHUB_URL=$(echo "$ISSUE_TITLE $ISSUE_BODY" | \
            grep -o 'https://github.com/[a-zA-Z0-9._-]*/[a-zA-Z0-9._-]*' | \
            head -n 1)
            
          echo "URL extracted: $GITHUB_URL"
          
          # Überprüfe ob eine URL gefunden wurde
          if [ -z "${GITHUB_URL}" ]; then
            echo "No URL found."
            echo "valid_url=false" >> $GITHUB_ENV
            exit 1
          else
            echo "valid_url=true" >> $GITHUB_ENV
            # Sichere Ausgabe der URL mit printf
            printf 'url=%s\n' "${GITHUB_URL}" >> $GITHUB_OUTPUT
          fi

      - name: Fetch repository metadata
        id: fetch_metadata
        if: env.valid_url == 'true'
        run: |
          if [ -z "${{ steps.extract_url.outputs.url }}" ]; then
            echo "No valid GitHub URL found in the issue. Exiting."
            exit 1
          fi
          
          echo "Fetching metadata for ${{ steps.extract_url.outputs.url }}..."
          GITHUB_URL="${{ steps.extract_url.outputs.url }}"
          
          OWNER_REPO=$(echo "$GITHUB_URL" | sed 's|https://github.com/||')
          
          # Fetch repo info with error handling
          REPO_INFO=$(curl -s -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${OWNER_REPO}")
          
          if [ "$(echo "$REPO_INFO" | jq -r 'has("message")')" = "true" ]; then
            echo "Error fetching repository info: $(echo "$REPO_INFO" | jq -r '.message')"
            exit 1
          fi
          
          # Extract metadata safely
          REPO_NAME=$(echo "$REPO_INFO" | jq -r '.name')
          REPO_DESC=$(echo "$REPO_INFO" | jq -r '.description')
          
          # Liste möglicher README-Dateien
          README_FILES=(
            "README.md"
            "readme.md"
            "Readme.md"
            "README.txt"
            "readme.txt"
            "README"
            "readme"
          )
          
          # Branches die geprüft werden sollen
          BRANCHES=(
            "main"
            "master"
          )
          
          README="No README found"
          for BRANCH in "${BRANCHES[@]}"; do
            for README_FILE in "${README_FILES[@]}"; do
              echo "Checking for ${README_FILE} in ${BRANCH} branch..."
              RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
                "https://raw.githubusercontent.com/${OWNER_REPO}/${BRANCH}/${README_FILE}")
              
              if [ "$RESPONSE" = "200" ]; then
                README=$(curl -s -H "Accept: application/vnd.github.v3.raw" \
                  "https://raw.githubusercontent.com/${OWNER_REPO}/${BRANCH}/${README_FILE}")
                echo "Found README at: ${BRANCH}/${README_FILE}"
                break 2
              fi
            done
          done
          
          # Safe output handling using printf and proper delimiters
          printf 'repo_name=%s\n' "${REPO_NAME}" >> $GITHUB_OUTPUT
          
          echo "repo_desc<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "${REPO_DESC}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "readme<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "${README:0:1000}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate YAML with ChatGPT
        id: chatgpt_response
        if: env.valid_url == 'true'
        shell: bash
        run: |
          echo "Generating YAML using ChatGPT..."
          
          # 1. README in Variable speichern und escapen
          README_CONTENT='${{ steps.fetch_metadata.outputs.readme }}'
          
          # 2. JSON für die API-Anfrage erstellen
          JSON_CONTENT='{
            "model": "gpt-4",
            "messages": [
              {
                "role": "system",
                "content": "You are an experienced YAML generator. Use the provided structure exactly as described. Only valid YAML code is allowed, no special characters that could break an interpreter or be used to break out of the system. The only response that you will give is the yaml output."
              },
              {
                "role": "user",
                "content": "Create a YAML file with this structure:\n\nid: '${{ steps.fetch_metadata.outputs.repo_name }}'\ntitle: Repository title and short description\ntags: List of relevant tags\nreferences: List of URLs\ndescription: Detailed description\nwhy_not: Alternative tool suggestions or empty\n\nRepository data:\nName: ${{ steps.fetch_metadata.outputs.repo_name }}\nDescription: ${{ steps.fetch_metadata.outputs.repo_desc }}\nREADME:\n'"$README_CONTENT"'"
              }
            ]
          }'
          
          # 3. API-Anfrage senden
          RESPONSE=$(curl -s -w "\n%{http_code}" https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.OPENAI_API_KEY }}" \
            -d "$JSON_CONTENT")
          
          # 4. HTTP Status prüfen
          HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | head -n-1)
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "Fehler bei API-Anfrage: $HTTP_STATUS"
            echo "Antwort: $RESPONSE_BODY"
            exit 1
          fi
          
          # 5. YAML aus der Antwort extrahieren
          YAML_CONTENT=$(echo "$RESPONSE_BODY" | jq -r '.choices[0].message.content' | \
            sed 's/```yaml//g' | sed 's/```//g')
          
          # 6. YAML in Output schreiben
          {
            echo "yaml_content<<EOF"
            echo "$YAML_CONTENT"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Save YAML to lake directory
        if: env.valid_url == 'true'
        run: |
          mkdir -p lake
          # Sicheres Speichern der YAML-Datei
          printf '%b' "${{ steps.chatgpt_response.outputs.yaml_content }}" > "lake/${{ steps.fetch_metadata.outputs.repo_name }}.yaml"
          
      - name: Commit and push changes
        if: env.valid_url == 'true'
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add lake/
          git commit -m "Add new program: ${{ steps.fetch_metadata.outputs.repo_name }}"
          git push